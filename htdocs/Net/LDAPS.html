<HTML>
<HEAD>
<TITLE>Net::LDAPS - use LDAP over an SSL connection</TITLE>
<LINK REV="made" HREF="mailto:hackers@FreeBSD.org">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->
<!--

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#CONSTRUCTOR">CONSTRUCTOR</A>
	<LI><A HREF="#ADDITIONAL_METHODS">ADDITIONAL METHODS</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
	<LI><A HREF="#BUGS">BUGS</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A>
</UL>
-->
<!-- INDEX END -->

<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Net::LDAPS - use LDAP over an SSL connection

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE> use Net::LDAPS;
</PRE>
<P>
<PRE> $ldaps = new Net::LDAPS('myhost.example.com',
                         port =&gt; '10000',
                         verify =&gt; 'require',
                         capath =&gt; '/usr/local/cacerts/');
</PRE>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
Communicate using the LDAP protocol to a directory server using a
potentially encrypted (SSL) network connection.

<P>
This class is a subclass of Net::LDAP so all the normal Net::LDAP methods
can be used with a Net::LDAPS object; see the documentation for Net::LDAP
to find out how to query a directory server using the LDAP protocol.

<P>
Note that the use of LDAPS is not recommended, because it is not described
by any IETF documents. Instead, you should consider using LDAPv3 with the
TLS extension defined in RFC 2830. This will give you the same
functionality as LDAPS, but using recognized standards. See
<A HREF="../Net/LDAP.html#start_tls">start_tls</A>.

<P>
<HR>
<H1><A NAME="CONSTRUCTOR">CONSTRUCTOR</A></H1>
<DL>
<DT><STRONG><A NAME="item_new">new ( HOST [, OPTIONS ] )</A></STRONG><DD>
<P>
Create a new connection. HOST is the hostname to contact. OPTIONS is a
number of key/value pairs - additional keys to those understood by
Net::LDAP::new are:

<DL>
<DT><STRONG><A NAME="item_verify">verify</A></STRONG><DD>
<P>
How to verify the server's certificate, either 'none' (the server may
provide a certificate but it will not be checked - this may mean you are be
connected to the wrong server), 'optional' (verify if the server offers a
certificate), or 'require' (the server must provide a certificate, and it
must be valid.) If you set verify to optional or require, you must also set
either cafile or capath. The most secure option is 'require'.

<DT><STRONG><A NAME="item_ciphers">ciphers</A></STRONG><DD>
<P>
Specify which subset of cipher suites are permissible for this connection,
using the standard OpenSSL string format. The default value for ciphers is
'ALL', which permits all ciphers, even those that don't encrypt!

<DT><STRONG><A NAME="item_clientcert">clientcert</A></STRONG><DD>
<DT><STRONG><A NAME="item_clientkey">clientkey</A></STRONG><DD>
<P>
If you want to use the client to offer a certificate to the server for SSL
authentication (which is not the same as for the LDAP Bind operation) then
set clientcert to the user's certificate file, and clientkey to the user's
private key file. These files must be in PEM format.

<DT><STRONG><A NAME="item_capath">capath</A></STRONG><DD>
<DT><STRONG><A NAME="item_cafile">cafile</A></STRONG><DD>
<P>
When verifying the server's certificate, either set capath to the pathname
of the directory containing CA certificates, or set cafile to the filename
containing the certificate of the CA who signed the server's certificate.
These certificates must all be in PEM format.

<P>
The directory in 'capath' must contain certificates named using the hash
value of themselves. To generate these names, use OpenSSL like this in
Unix:

<P>
<PRE>    ln -s cacert.pem `openssl x509 -hash -noout &lt; cacert.pem`.0
</PRE>
<P>
(assuming that the certificate of the CA is in cacert.pem.)

</DL>
</DL>
<P>
<HR>
<H1><A NAME="ADDITIONAL_METHODS">ADDITIONAL METHODS</A></H1>
<DL>
<DT><STRONG><A NAME="item_cipher">cipher</A></STRONG><DD>
<P>
Returns the cipher mode being used by the connection, in the string format
used by OpenSSL.

<DT><STRONG><A NAME="item_certificate">certificate</A></STRONG><DD>
<P>
Returns an X509_Certificate object containing the server's certificate. See
the IO::Socket::SSL documentation for information about this class.

<P>
For example, to get the subject name (in a peculiar OpenSSL-specific
format, different from RFC 1779 and RFC 2253) from the server's
certificate, do this:

<P>
<PRE>    print &quot;Subject DN: &quot; . $ldaps-&gt;certificate-&gt;subject_name . &quot;\n&quot;;
</PRE>
</DL>
<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<A HREF="../Net/LDAP.html">Net::LDAP</A>,
<A HREF="../IO/Socket/SSL.html">IO::Socket::SSL</A>



<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
Several apparently bogus warnings are emitted when initializing the two
underlying modules used by Net::LDAPS, namely IO::Socket::SSL and
Net::SSLeay. To avoid these, don't initialize via 'use Net::LDAPS' and
instead try initializing Net::LDAPS like this:

<P>
<PRE>    BEGIN {
        # Turn off all warnings etc whilst initializing
        # IO::Socket::SSL and Net::SSLeay.
        local $^W = 0;
        no strict;
        require Net::SSLeay;
        # The /dev/urandom is a device on Linux that returns
        # random data.
        Net::SSLeay::randomize('/dev/urandom');
        require Net::LDAPS;
    }
</PRE>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
Chris Ridd &lt;<A
HREF="mailto:chris.ridd@messagingdirect.com">chris.ridd@messagingdirect.com</A>&gt;


<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
Copyright (c) 2000-2001, Chris Ridd and Graham Barr. All rights reserved.
This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

</BODY>

</HTML>
